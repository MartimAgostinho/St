/**
 * Sistemas de Telecomunicacoes
 *          2022/2023
 *
 * Web_server_main_thread.java
 *
 * Main class with graphical interface and server control logic
 *
 * Created on March 20, 2022
 *
 * @author Luis Bernardo
 */
package server;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import javax.swing.JFileChooser;
import javax.swing.JTextField;

public class Web_server_main_thread extends javax.swing.JFrame {

    /**
     * Server name
     */
    public final static String SERVER_NAME = "Demo HTTP Serv 2022/2023";
    /**
     * Default html directory
     * TASK 6.0 - change this constant to have the location of the html directory in your computer
     */
    public final static String HTML_DEFAULT_DIRECTORY = "/home/porcaontas/St/ST_lab4_students/html";
    /**
     * Maximum packet size for AUTH_REQ and AUTH_REP
     */
    public final static int MAX_PACKET_LENGTH = 120;
    /**
     * Default file name when browser sends "/"
     */
    public final static String HOMEFILENAME = "index.htm";
    /**
     * Accepts up to 10 pending TCP connections
     */
    public final static int MAX_ACCEPT_LOG = 10;
    /**
     * AUTH_REQ packet type
     */
    public final static int AUTH_REQ = 1;
    /**
     * AUTH_REP packet type
     */
    public final static int AUTH_REP = 2;
    /**
     * Maximum timeout waiting for answer from Authentication server [ms]
     */
    public final static int AUTH_TIMEOUT = 1000;
    /**
     * Maximum time a password can be stored in cache [ms]
     */
    public final static int MAX_PASSW_STORE_TIME = 60000;
    /**
     * Server socket where new connections are accepted
     */
    public ServerSocket ssock;
    /**
     * Thread that accepts new connections
     */
    Thread_tcp_accept tcp_accept = null;
    /**
     * Datagram socket used to send REGIST messages to the proxy
     */
    public DatagramSocket ds;
    /**
     * Sequence number for AUTH_REQ messages
     */
    private static int seq_AUTH_Req = 0;
    /**
     * HashMap with list of stored challenges
     */
    /********************************
     * TASK 7.1: 
     *      define and create a new HashMap object to store User_credentials objects. 
     */
    // private final HashMap<String, User_credentials> user_database = ...

    /**
     * Constructor
     */
    public Web_server_main_thread(String html_dir) {
        initComponents();
        super.setTitle(SERVER_NAME);
        ds = null;
        ssock = null;
        if (html_dir == null)
            this.jTextHtmlRoot.setText(HTML_DEFAULT_DIRECTORY);
        else
            this.jTextHtmlRoot.setText(html_dir);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jPanel1 = new javax.swing.JPanel();
        jToggleButtonActive = new javax.swing.JToggleButton();
        jLabel5 = new javax.swing.JLabel();
        jTextLocalIP = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jTextLocalPort = new javax.swing.JTextField();
        jPanel3 = new javax.swing.JPanel();
        jLabelHtml = new javax.swing.JLabel();
        jTextHtmlRoot = new javax.swing.JTextField();
        jPanel4 = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        jTextUser = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextLifetime = new javax.swing.JTextField();
        jButtonTest = new javax.swing.JButton();
        jButtonClear = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jTextAuthIP = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jTextAuthPort = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setTitle("Defined in constructor");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        jPanel1.setMaximumSize(new java.awt.Dimension(450, 35));
        jPanel1.setMinimumSize(new java.awt.Dimension(450, 35));
        jPanel1.setName("Estado"); // NOI18N
        jPanel1.setPreferredSize(new java.awt.Dimension(450, 35));

        jToggleButtonActive.setText("Active");
        jToggleButtonActive.setMaximumSize(new java.awt.Dimension(85, 29));
        jToggleButtonActive.setPreferredSize(new java.awt.Dimension(85, 29));
        jToggleButtonActive.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButtonActiveActionPerformed(evt);
            }
        });
        jPanel1.add(jToggleButtonActive);

        jLabel5.setText("IP");
        jPanel1.add(jLabel5);

        jTextLocalIP.setEditable(false);
        jTextLocalIP.setPreferredSize(new java.awt.Dimension(200, 20));
        jPanel1.add(jTextLocalIP);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel4.setText("Port");
        jLabel4.setMaximumSize(new java.awt.Dimension(35, 17));
        jLabel4.setPreferredSize(new java.awt.Dimension(35, 17));
        jPanel1.add(jLabel4);

        jTextLocalPort.setText("20000");
        jPanel1.add(jTextLocalPort);

        getContentPane().add(jPanel1);

        jPanel3.setMaximumSize(new java.awt.Dimension(390, 37));
        jPanel3.setMinimumSize(new java.awt.Dimension(60, 33));
        jPanel3.setPreferredSize(new java.awt.Dimension(480, 33));

        jLabelHtml.setText("Html:");
        jLabelHtml.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabelHtmlMouseClicked(evt);
            }
        });
        jPanel3.add(jLabelHtml);

        jTextHtmlRoot.setText("Click 'Html:' to select HTML directory");
        jTextHtmlRoot.setPreferredSize(new java.awt.Dimension(330, 24));
        jTextHtmlRoot.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextHtmlRootFocusLost(evt);
            }
        });
        jTextHtmlRoot.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextHtmlRootActionPerformed(evt);
            }
        });
        jPanel3.add(jTextHtmlRoot);

        getContentPane().add(jPanel3);

        jPanel4.setMaximumSize(new java.awt.Dimension(32767, 39));

        jLabel9.setText("User:");
        jPanel4.add(jLabel9);

        jTextUser.setText("user");
        jTextUser.setPreferredSize(new java.awt.Dimension(50, 26));
        jPanel4.add(jTextUser);

        jLabel2.setText("Lifetime:");
        jPanel4.add(jLabel2);

        jTextLifetime.setText("60000");
        jTextLifetime.setPreferredSize(new java.awt.Dimension(70, 26));
        jPanel4.add(jTextLifetime);

        jButtonTest.setBackground(new java.awt.Color(255, 255, 0));
        jButtonTest.setText("Test server");
        jButtonTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTestActionPerformed(evt);
            }
        });
        jPanel4.add(jButtonTest);

        jButtonClear.setBackground(new java.awt.Color(255, 255, 0));
        jButtonClear.setText("Clear");
        jButtonClear.setMaximumSize(new java.awt.Dimension(75, 29));
        jButtonClear.setPreferredSize(new java.awt.Dimension(75, 29));
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });
        jPanel4.add(jButtonClear);

        getContentPane().add(jPanel4);

        jPanel2.setToolTipText("configuração");
        jPanel2.setMaximumSize(new java.awt.Dimension(440, 35));
        jPanel2.setMinimumSize(new java.awt.Dimension(420, 35));
        jPanel2.setName("configuracao"); // NOI18N
        jPanel2.setPreferredSize(new java.awt.Dimension(440, 35));

        jLabel1.setText("  Auth Server:");
        jPanel2.add(jLabel1);

        jLabel3.setText("  IP ");
        jPanel2.add(jLabel3);

        jTextAuthIP.setEditable(false);
        jTextAuthIP.setText("127.0.0.1");
        jTextAuthIP.setMinimumSize(new java.awt.Dimension(14, 27));
        jTextAuthIP.setPreferredSize(new java.awt.Dimension(130, 24));
        jPanel2.add(jTextAuthIP);

        jLabel6.setText("Port ");
        jPanel2.add(jLabel6);

        jTextAuthPort.setText("20001");
        jTextAuthPort.setPreferredSize(new java.awt.Dimension(60, 24));
        jPanel2.add(jTextAuthPort);

        getContentPane().add(jPanel2);

        jScrollPane1.setPreferredSize(new java.awt.Dimension(360, 180));

        jTextArea1.setLineWrap(true);
        jTextArea1.setPreferredSize(new java.awt.Dimension(200, 2000));
        jTextArea1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextArea1KeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(jTextArea1);

        getContentPane().add(jScrollPane1);

        getAccessibleContext().setAccessibleName("HTTP GUI - RIT2 2011/2012 by ?????/?????/?????");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Validates the html root directory name where the files are read
     *
     * @param f
     */
    public void validate_name(javax.swing.JTextField f) {
        String str = f.getText();
        if (str.length() == 0) {
            return;
        }
        str = str.trim();
        if (str.charAt(str.length() - 1) != File.separatorChar) {
            str = str + File.separatorChar;
        } else {
            while ((str.length() > 1) && (str.charAt(str.length() - 2) == File.separatorChar)) {
                str = str.substring(0, str.length() - 1);
            }
        }
        f.setText(str);
    }

    /**
     * Automatically validates the html directory name
     * 
     * @param evt 
     */
    private void jTextHtmlRootFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextHtmlRootFocusLost
        validate_name(jTextHtmlRoot);
    }//GEN-LAST:event_jTextHtmlRootFocusLost

    /**
     * Clear the text area
     */
    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        jTextArea1.setText("");
    }//GEN-LAST:event_jButtonClearActionPerformed

    /**
     * Clear the text area
     */
    private void jTextArea1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextArea1KeyPressed
        if (evt.getKeyChar() == ' ') {
            jTextArea1.setText("");
        }
    }//GEN-LAST:event_jTextArea1KeyPressed

    /**
     * Test the communication with the Authentication server
     *
     * @param evt
     */
    private void jButtonTestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTestActionPerformed
        if (!jToggleButtonActive.isSelected()) {
            Log("Server is not active\n");
            return;
        }
        try {
            User_credentials this_user = this.get_challengeresponse(this.jTextUser.getText());
            Log("Returned challenge_response= " + (this_user == null ? "null" : this_user.toString()) + "\n");
        } catch (Exception e) {
            Log("Error testing CountServer: " + e + "\n");
        }

    }//GEN-LAST:event_jButtonTestActionPerformed

    /**
     * Open a directory selection window to select the HTML root
     */
    private void select_html_directory() {
        try {
            // Choose file to write the list
            this.jFileChooser1.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            if (jFileChooser1.showDialog(this, "Select directory with html files") == JFileChooser.APPROVE_OPTION) {
                File f = jFileChooser1.getSelectedFile();
                this.jTextHtmlRoot.setText(f.getAbsolutePath());
            }
        } catch (Exception e) {
            System.err.println("Error selecting html directory:" + e);
        }
    }

    private void jLabelHtmlMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabelHtmlMouseClicked
        select_html_directory();
    }//GEN-LAST:event_jLabelHtmlMouseClicked

    private void jTextHtmlRootActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextHtmlRootActionPerformed
        select_html_directory();
    }//GEN-LAST:event_jTextHtmlRootActionPerformed

    /**
     * Handles the Active button pressing events
     *
     * @param evt
     */
    private void jToggleButtonActiveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButtonActiveActionPerformed
        if (jToggleButtonActive.isSelected()) {
            // Starting the server
            
            // Parse GUI parameters            
            int tcp_port;
            try {
                tcp_port = Integer.parseInt(jTextLocalPort.getText());
            } catch (NumberFormatException e) {
                Log("Invalid port number\n");
                jToggleButtonActive.setSelected(false);
                return;
            }
            // Starts the server socket
            int cnt = 0;
            do {
                try {
                    ssock = new ServerSocket(tcp_port + cnt, MAX_ACCEPT_LOG);
                } catch (java.io.IOException e) {
                    // If the tcp_port is already used, try the next one until reaching a free one
                    if (cnt > 100) {
                        Log("Web server start failure: " + e + "\n");
                        jToggleButtonActive.setSelected(false);
                        return;
                    }
                    cnt++;
                }
            } while (ssock == null);
            jTextLocalPort.setText(Long.toString(tcp_port + cnt)); // Writes the port used.

            // Gets the local IP
            try {
                jTextLocalIP.setText(InetAddress.getLocalHost().getHostAddress());
            } catch (UnknownHostException e) {
                Log("Failed to get local IP: " + e + "\n");
            }

            // Start the UDP socket to communicate with the authentication server
            /********************************
             * TASK 5.1: 
             *      create a new DatagramSocket ds and configure it. 
             */
            // Remember to add try / catch as is described in the tutorial document:
            
            try {
              ds = new DatagramSocket();
            } catch (SocketException ex) {
                Log("Failed creation of UDP socket: " + ex + "\n");
                try {
                    ssock.close();
                } catch (IOException ex1) {
                    Log("Error closing TCP socket: " + ex1 + "\n");
                    ssock = null;
                }
                jToggleButtonActive.setSelected(false);
                return;
            }

            // starts the main thread (that receives connections)
            tcp_accept = new Thread_tcp_accept(this, ssock);
            tcp_accept.start();

            setEditable_jText(false);
            Log("Web server active\n");
            
        } else {
            // Stopping the server
            
            // Stop the server socket thread and the sockets
            try {
                /********************************
                 * TASK 5.1: 
                 *      close the DatagramSocket ds and free the object.
                 */
                // ...

                if(ds != null){
                    ds.close();
                    ds = null;
                }
                
                if (tcp_accept != null) {
                    tcp_accept.stop_thread();
                    tcp_accept = null;
                }
                if (ssock != null) {
                    ssock.close();
                    ssock = null;
                }
            } catch (IOException e) {
                Log("Exception closing server: " + e + "\n");
            }
            setEditable_jText(true);
            Log("Web server stopped\n");
        }
    }//GEN-LAST:event_jToggleButtonActiveActionPerformed

    /**
     * Handles the main window closing event - closes the application
     * 
     * @param evt 
     */
    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        System.exit(0); // Closes the application
    }//GEN-LAST:event_formWindowClosing

    /**
     * Authentication server's IP address
     *
     * @return IP address
     */
    public InetAddress get_AuthServer_IP() {
        String str = jTextAuthIP.getText();
        try {
            return InetAddress.getByName(str);
        } catch (UnknownHostException e) {
            Log("Invalid AuthServer IP address '" + str + "': " + e + "\n");
            return null;
        }
    }

    /**
     * Authentication server's port number
     *
     * @return port number
     */
    public int get_AuthServer_Port() {
        String str = this.jTextAuthPort.getText();
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            Log("Invalid AuthServer port number '" + str + "': " + e + "\n");
            return 0;
        }
    }

    /**
     * Authentication lifetime value
     *
     * @return port number
     */
    public int get_Lifetime_value() {
        String str = this.jTextLifetime.getText();
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            Log("Invalid Lifetime value '" + str + "': " + e + "\n");
            return MAX_PASSW_STORE_TIME;
        }
    }

    /**
     * Send a AUTH_REQ message to the Authentication server
     *
     * @param servIP Authentication server's IP address
     * @param servPort Authentication server's port number
     * @param user Requested user authentication information
     * @param seq Unique sequence number
     * @return true is AUTH_REQ was sent successfuly
     */
    boolean send_AUTH_REQ(InetAddress servIP, int servPort, String user, int seq) {

        // Validate contents
        if ((servIP == null) || (servPort <= 0) || (user == null)) {
            Log("Invalid parameter in send_AUTH_REQ");
            return false;
        }
        // Create and send packet
        ByteArrayOutputStream os = new ByteArrayOutputStream(); // Prepares a message 
        DataOutputStream dos = new DataOutputStream(os);        //   writting object
        try {
            /********************************
             * TASK 5.2: 
             *      prepare and send the AUTH_REQ message.
             *      The structure is the following:
             */
            // Message AUTH_REQ is an ordered sequence of:
            //  byte type;          // Message type == 1
            //  int seq;            // Request sequence number
            //  short len_user;     // Length of username
            //  byte[] user;        // username
            /********************************
             *      Start by writing the various elements to "dos"
             *      copy to a byte array
             *      construct a datagram object
             * See UDP chat for enlightening
             */

            dos.writeByte(1);
            dos.writeInt(seq);
            dos.writeShort(user.length());
            dos.writeBytes(user);
            byte[] buffer = os.toByteArray();
            
            DatagramPacket dp = new DatagramPacket(buffer,buffer.length); // Create packet
            ds.connect(servIP,servPort);
            ds.send(dp);

            Log("Sent AUTH_REQ (" + seq + ";" + user + ") to " + servIP + ":" + servPort + "\n");
            return true;
        } catch (Exception e) {
            // Catches all exceptions
            Log("Error preparing or sending AUTH_REQ message: " + e + "\n");
            return false;
        }
    }

    /**
     * Controls editability of jTexts
     *
     * @param editable
     */
    public void setEditable_jText(boolean editable) {
        jTextLocalPort.setEditable(editable);
        jTextHtmlRoot.setEditable(editable);
    }

    /**
     * Logs a message on the command line and on the text area
     *
     * @param s string to be written
     */
    public void Log(String s) {
        jTextArea1.append(s);
        System.out.print(s);
    }

    /**
     * Returns the port number in a JTextField
     */
    private int getPort(JTextField jt) {
        try {
            int port = Integer.parseInt(jt.getText());
            if ((port <= 0) || (port > 65535)) {
                return 0;
            }
            return port;
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    /**
     * Returns the local TCP port number
     *
     * @return local port number
     */
    public int getLocalPort() {
        return getPort(jTextLocalPort);
    }

    /**
     * Returns the Authentication server's UDP port number
     *
     * @return proxy port number
     */
    public int getAuthServPort() {
        return getPort(jTextAuthPort);
    }

    /**
     * Returns the root html directory
     *
     * @return string with the root pathname
     */
    public String getRootHtmlDirectory() {
        return jTextHtmlRoot.getText();
    }

    /**
     * Increments the AUTH_REQ sequence number and returns it
     *
     * @return sequence number
     */
    public int get_NextSEQ() {
        return ++seq_AUTH_Req;
    }

    /**
     * Auxiliary function to read a String from a DataInputStream
     *
     * @param dis DataInputStream associated to a socket or a file
     * @return String received
     * @throws IOException
     */
    public static String read_String(DataInputStream dis) throws IOException {
        short len = dis.readShort();
        if (len > 0) {
            byte[] buf = new byte[len];
            dis.read(buf);
            return new String(buf);
        } else {
            return "";
        }
    }

    /**
     * Function that sends AUTH_REQ and receives AUTH_REP messages
     *
     * @param user user id
     * @return User_credentials object with authentication data, or new
     */
    private User_credentials get_challengeresponse_from_server(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }

        byte[] buf = new byte[MAX_PACKET_LENGTH];
        DatagramPacket rdp = new DatagramPacket(buf, buf.length);
        // Parameters in AUTH_REQ
        int seq;
        // Parameters received in AUTH_REP
        byte rtype;
        int rseq;
        int csize;
        int[] challenge = new int[3];
        String ruser = null, response= null;

        seq = get_NextSEQ(); // Get next sequence number
        try {
            ds.setSoTimeout(1000);
            send_AUTH_REQ(get_AuthServer_IP(), get_AuthServer_Port(),
                    user, seq);

            /********************************
             * TASK 5.3: 
             *      a) Read all the fields of AUTH_REP, using the dis object,
             *           according to the protocol to the local variables declared above
             *      b) Test if the values received match the ones sent (user, seq)
             *      c) Create a new User_credentials object with the data 
             *          received (including an empty response (length 0)).
             */

            ds.receive(rdp);
            Log("Acabei de receber\n");
            ByteArrayInputStream BAis= new ByteArrayInputStream(buf, 0, rdp.getLength());
            DataInputStream dis = new DataInputStream(BAis);
            
            // Parse Auth_Rep message
            //Log("Function HttpdServ.get_challengeresponse_from_server is incomplete.\n");
            
            // Implement a) here
            // Message AUTH_REQ is an ordered sequence of:
            //  byte type;          // Message type == 2
            //  short len_user;     // Length of username
            //  byte[] user;        // username
            //  int seq;            // AUTH_REQ sequence number
            //  short len_challenge;// Length of challenge sent == 3 (valid user) / 0 (invalid user)
            //  byte[] response;    // Three response characters
            //  byte challenge[0];  // position 1 in the password string 
            //  byte challenge[1];  // position 2 in the password string 
            //  byte challenge[2];  // position 3 in the password string
            
            rtype = dis.readByte();
            Log("Recebeu o byte "+ rtype +"\n");
            if(rtype != 2){return null;}
            
            ruser = read_String(dis);
            Log("Recebeu o user "+ ruser +"\n");

            //if(ruser == ""){return null;}
            
            rseq = dis.readInt();
            Log("Recebeu o seq "+ rseq +"\n");

            response = read_String(dis);
            Log("Recebeu o response "+ response +"\n");

            if(response.length() != 3 ){ return null; }
            
            challenge[0] = dis.readByte();
            Log("Recebeu o challenge1 "+ challenge[0] +"\n");
            challenge[1] = dis.readByte();
            Log("Recebeu o challenge2 "+ challenge[1] +"\n");
            challenge[2] = dis.readByte();
            Log("Recebeu o challenge3 "+ challenge[2] +"\n");
            //      Do not forget to handle messages too short (use Error 1 in Authentication server to test it)
            //      Do not forget to handle messages too long (use Error 2 in Authentication server to test it)

            /*  // Use this code to log the content of AUTH_REP message*/
            if (response.length() > 0)
                Log("Received AUTH_REP (C:"+challenge[0]+challenge[1]+challenge[2]+"-R:"+
                    response+") from "+
                    rdp.getAddress().getHostAddress()+":"+rdp.getPort()+"\n");
            else{
                Log("Received AUTH_REP (no user) from "+
                    rdp.getAddress().getHostAddress()+":"+rdp.getPort()+"\n");
                    return null;
            }
            
            // Implement b) - Validate rseq and ruser

            if( rseq != seq || !ruser.equals(user) ){
                //innvalid user || seq
                Log(rseq +" !="+ seq +"\n"+ruser +"!="+ user+"\n");
                return null;
            }
            // Implement c) create User_credentials object
            User_credentials re =  new User_credentials (user,
                    challenge, response, get_Lifetime_value());

            /********************************
             * TASK 7.2 
             *      Store the User_credentials object in the database created
             *      in task 7.1 when a valid challenge-response vector is 
             *      received.
             */
            // ...

            
            return re;
        } catch (IOException ex) {
            // Error in reading from buffer - packet too short
            Log("Error in communication with authentication server:(catch 1)\n "+ex+"\n");
            return null;
        } catch (Exception ex) {
            // Error in communication
            Log("Exception in function get_challengeresponse:\n "+ex+"\n");
            return null;
        }  
    }

    /**
     * Function that looks for authentication data in the cache user_database
     *
     * @param user user id
     * @return User_credentials object with authentication data
     */
    private User_credentials get_cached_challengeresponse(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }
        /********************************
         * TASK 7.3 
         *      Lookup the user_database for the user, and return a
         *      cached User_credentials if it is still valid.
         */
        // ...
        return null;
    }

    /**
     * Function that gets a User_credentials. First sees if it is in
     * cache and gets a new one if none is available
     *
     * @param user user id
     * @return User_credentialsper object with authentication data, or null
     */
    public User_credentials get_challengeresponse(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }
        User_credentials this_user = get_cached_challengeresponse(user);
        if (this_user == null) {
            this_user = get_challengeresponse_from_server(user);
            Log("Devolveu o this_user  " + this_user+"\n");
            if (this_user != null) {
                Log("Using new challenge-response\n");
            } else {
                Log("No challenge-response\n");
            }
        } else {
            Log("Using cached challenge-response\n");
        }

        return this_user;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        String html_dir= (args.length > 0) ? args[0] : HTML_DEFAULT_DIRECTORY;
        new Web_server_main_thread(html_dir).setVisible(true);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonTest;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JLabel jLabelHtml;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextAuthIP;
    private javax.swing.JTextField jTextAuthPort;
    private javax.swing.JTextField jTextHtmlRoot;
    private javax.swing.JTextField jTextLifetime;
    private javax.swing.JTextField jTextLocalIP;
    private javax.swing.JTextField jTextLocalPort;
    private javax.swing.JTextField jTextUser;
    private javax.swing.JToggleButton jToggleButtonActive;
    // End of variables declaration//GEN-END:variables
}
